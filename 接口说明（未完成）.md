
---
## 前言
为了尽可能降低开发难度，也避免反复手写任务关联等逻辑时出现错误，在我的设想里是通过封装将抽象逻辑与渲染是完全分离，所以在制作具体场景前请尽可能详细阅读这篇文档

开发中所有的物品状态、任务依赖、剧情分支....完全由该引擎决定，**前端开发时不应该考虑诸如此类的逻辑问题**，所有固定参数（文本、依赖等）我将通过配置文件进行设置，具体的工作流参考第四部分示例

是的这个所谓的引擎其实代码量也就几百行，单纯由于本人逻辑能力低下一直写不明白才写了这么久
##  WASM 引擎接口文档


引擎通过 `wasm_exec.js` 胶水层将函数暴露在浏览器全局对象 `window` 下。**所有复杂对象均通过 JSON 字符串进行传递**。

### 1. 核心导出函数

#### `window.initEngine(configJSON, saveJSON)`

**用途**：启动并初始化引擎。必须在所有其他操作之前调用。

* **参数**：
* `configJSON` (string): 外部配置的完整的 `WorldConfig` JSON。包含场景、任务和静态交互定义。
* `saveJSON` (string): 可选。上一次存档的 JSON 字符串。若传空字符串或 `null`，则开启新游戏。


* **返回值**：`boolean` - 初始化成功返回 `true`。

#### `window.handleAction(actionJSON)`

**用途**：最核心的函数，处理用户几乎所有的交互动作（点击、拖拽、解密等）。

* **参数**：
* `actionJSON` (string): `InteractionInput` 结构的 JSON 字符串。


* **返回值**：`string` - `InteractionResult` 结构的 JSON 字符串。前端需解析此结果来驱动 UI 和动画。

#### `window.getGameStateJSON()`

**用途**：获取当前最新的完整存档数据。

* **返回值**：`string` - `GameSaveData` 结构的 JSON 字符串。前端应将其存入 `localStorage` 或文件系统。

#### `window.loadGameStateJSON(saveJSON)`

**用途**：在游戏运行中途即时读档（如用户点击“加载进度”按钮）。

* **参数**：
* `saveJSON` (string): 存档 JSON。


* **返回值**：`boolean` - 读档成功返回 `true`。

---

### 2. 数据结构定义 (JSON 协议)

####  输入结构：`InteractionInput`

前端通过此结构告诉引擎玩家做了什么。

| 字段 | 类型 | 说明 |
| --- | --- | --- |
| `action` | string | 动作类型：`CLICK` (点击), `DRAG` (拖拽使用物品), `INPUT` (输入密码), `CUSTOM` (小游戏反馈) |
| `target` | string | 交互对象的 ID（如 `iron_door`, `old_chest`） |
| `item` | string | (可选) 玩家当前选中的物品 ID |
| `code` | string | (可选) 输入的密码字符或小游戏状态码 |

####  输出结构：`InteractionResult`

引擎处理后返回的结果，前端根据此结果执行视觉反馈。

| 字段 | 类型 | 说明 |
| --- | --- | --- |
| **`status`** | string | **核心状态**：`SUCCESS` (成功), `FAIL` (失败), `DIALOGUE` (触发对话), `OPEN_SUBVIEW` (弹出UI/小游戏), `CHANGE_SCENE` (切场景), `NONE` (无反应) |
| `message` | string | 简短的消息提示（如“门锁住了”） |
| `dialogue` | string[] | 对话内容数组，若非空则需启动对话框 |
| `speaker` | string | 当前说话人的姓名或 ID |
| `sub_view_id` | string | 需弹出的 Prefab/UI 界面 ID（对应解密特写或小游戏） |
| `next_scene_id` | string | 目标场景 ID（仅在切场景时有效） |
| `trigger_event` | string | 需触发的 Cocos 动画或音效名称（如 `door_open_sfx`） |
| `updated_flags` | object | 键值对。更新当前场景相关的 Flag 状态（如 `{ "torch_lit": 1 }`） |
| `new_items` | string[] | 玩家新获得的物品 ID 列表 |
| `remove_item` | string | 逻辑上被消耗掉的物品 ID（前端需从背包移除） |
| `auto_save` | boolean | **关键提示**：若为 `true`，建议前端立即调用 `getGameStateJSON` 并进行存档 |

---

### 3. 常量枚举参考

前端在处理 `status` 或 `action` 时，建议建立对应映射：

| 常量名称 | 值 | 含义 |
| --- | --- | --- |
| **StatusSuccess** | `"SUCCESS"` | 一般成功反馈 |
| **StatusFail** | `"Fail"` | 一般失败反馈 | 
| **StatusDialogue** | `"DIALOGUE"` | 需锁定玩家输入，展示对话框 |
| **StatusOpenSubView** | `"OPEN_SUBVIEW"` | 需弹出特写界面或小游戏 |
| **StatusChangeScene** | `"CHANGE_SCENE"` | 调用 `cc.director.loadScene` |
| **QuestTypeCustom** | `"CUSTOM"` | 表示该解密小游戏是在前端 Cocos 里完成的，完成后传回 `action: "CUSTOM"` |
| **QuestTypeClick** | `"Click"` | 表示用户完成了点击类型解密，完成后传回 `action:"Click"` |
| **QuestTypeDrag** | `"Drag"` | 表示用户进行了拖拽类型解密，完成后传回 `action: "Drag"` |
| **QuestTypeInput** | `"Input"` | 表示用户进行了输入类型解密，完成后传回`action: "Input"` |
---

### 4. 前端交互建议工作流

1. **加载**：
* 加载 `engine.wasm` 和配置表。
* 调用 `initEngine`。


2. **一个完整的交互流程如下**：
* 用户点击场景物体 `A`。
* 捕获点击后，发送 `handleAction({action: "CLICK", target: "A"})` 到 WASM。
* 解析返回的 `InteractionResult`：
* 如果有 `trigger_event` -> 播放对应的 Cocos Animation。
* 如果 `status` 是 `DIALOGUE` -> 弹出对话框循环展示 `dialogue` 数组。
* 如果 `status` 是 `CUSTOM` -> 弹出对应的Prefab（基本上都对应的是小游戏）
* 如果 `auto_save` 是 `true` -> 异步调用存档逻辑。
* 其余参数参考前文说明


3. **状态同步**：
* 每当返回 `updated_flags` 时，前端应遍历并更新场景内关联的 Node 状态（如显示/隐藏、更换皮肤）。



---

### 5. 存档文件格式 (`GameSaveData`)

前端从 `getGameStateJSON` 拿到的是一个包含元数据的包装对象：

```json
{
  "state": {
    "scene_id": "living_room",
    "inventory": ["key_01", "old_photo"],
    "world_flags": { "light_on": 1, "door_opened": 0 },
    "active_quest_id": ["quest_find_key"],
    "completed_quests": { "quest_enter_house": true }
  },
  "timestamp": 1705912345,
  "version": "1.0.0"
}

```


前端从 ` `